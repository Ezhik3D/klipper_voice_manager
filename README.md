# Система голосовых уведомлений Klipper  



https://github.com/user-attachments/assets/3a71bfa2-baea-4c68-b692-876002da0d67




## Вступление

Итак, начнём по порядку: **для чего и кому нужен этот проект**.

Klipper — очень мощная и развитая система, можно мониторить его состояние и состояние печати множеством способов. Но вот представьте: вы дома запустили печать, заняты своими делами, и вам нужно постоянно заглядывать в какой-то гаджет, чтобы увидеть статусы, прогресс и т.п.

А тут — **автономная система озвучки** с минимальным порогом вхождения: поставил и настраивай как хочешь (об этом позже). Вы делаете свои дела, а умная система нежным женским голосом говорит о начале печати, завершении печати, паузах и возобновлениях, обдуве, температуре, прогрессе. В общем, все полезные оповещения, максимально приближённые не к роботизированной озвучке, а к человеческой речи, с правильными формами склонения и т.п. Вы слышите всё, что нужно, не заглядывая в гаджеты, и спокойно продолжаете свои дела. Очень удобно, когда попробуешь хоть раз.

У меня уже был проект озвучки, и он работал, но высокий порог вхождения отбивал желающих им пользоваться. Немного вернувшись в 3D-печать и обсуждая с друзьями, что пропустил за годы, выяснилось, что старой озвучкой пользуется только один человек, и он из-за моего отсутствия даже не обновлял Klipper — это наверняка сломало бы макросы, а починить у него не было знаний.

Тогда ребята указали мне в сторону нейросетей. К сегодняшнему дню они очень шагнули вперёд, но есть нюансы: вечный Альцгеймер, навязчивая попытка тихо «исправить» то, что не просишь, ломая одно при правке другого, ограничения по объёму кода и т.д. За месяц работы с ними я научился с этим бороться, за второй месяц проект пережил десять или более переписываний почти с нуля. В итоге проект заработал как надо, ещё полмесяца ушло на его использование «в хвост и в гриву», отлавливание и исправление багов.

В итоге проект готов. Дарю его всем, кому он нужен.  
С уважением, ваш Йожик.

---

## Внимание! Прежде чем менять что-то в config.yaml создайте его резервную копию.
## Рекомендуется открывать его в notepad++ через WinSCP 
## В config.yaml проверяйте синтаксис (отступы, двоеточия, кавычки).

## Работа с системой озвучки: настройки и важные пояснения

Вся система озвучки построена на **текстовых сообщениях** — они же *алиасы*. При формировании алиасов модули оповещения формируют (если нужно) нужные склонения, затем на основе этих алиасов выводится звук. Алиасы могут быть как одиночными, так и составными. По идее: один алиас = один файл звука, но можно работать и с составными (об этом ниже).

В системе существует `config_manager`, который в реальном времени мониторит изменения `config.yaml` и передаёт всю актуальную информацию всем модулям, которым это нужно, а также отдельно организовывает изменения по подпискам для критически важных модулей. Вся система полностью настраивается через этот конфиг и **автоматически, без перезагрузки**, применяет настройки.

Ниже — подробный разбор секций.

---

## Доступ к Klipper API

```yaml
klipper:
  host: 127.0.0.1       # IP-адрес для подключения к Klipper
  port: 7125            # Порт подключения Klipper
  websocket_path: /websocket  # Путь к WebSocket на сервере Klipper
```

```yaml
websocket:
  ping_interval: 30          # Интервал отправки ping для поддержки соединения
  ping_timeout: 10           # Время ожидания pong ответа
  close_timeout: 5           # Время ожидания закрытия WebSocket
  send_timeout: 5            # Таймаут на отправку сообщений
  reconnect_delay: 5         # Задержка между попытками переподключения
  thread_join_timeout: 3     # Таймаут ожидания завершения потока WebSocket клиента
  run_forever_max_iterations: 60  # Максимальное число итераций run_forever до перезапуска
```

Тут всё понятно из комментариев. Стоит обратить внимание на секцию `websocket:` — **когда и зачем её настраивать**.

### Оптимизация для разных условий

**Стабильная локальная сеть (дома):**

```yaml
websocket:
  ping_interval: 20    # ↓ чаще проверяем
  ping_timeout: 5      # ↓ быстрее реагируем
  send_timeout: 10     # ↑ больше времени на отправку
  reconnect_delay: 10  # ↑ не спешим переподключаться
```

**Очень слабое оборудование (старый Raspberry Pi):**

```yaml
websocket:
  ping_interval: 60    # реже пингуем
  ping_timeout: 15
  send_timeout: 10
  reconnect_delay: 15
```

Эта секция простая, комментарии сами говорят за себя.

---

## Настройки звукового менеджера (Pygame mixer)

```yaml
sound_manager:
  # Общая громкость воспроизведения (0.0 = тишина, 1.0 = максимум)
  # Значение 0.7: компромисс между слышимостью и комфортом (не режет слух)
  volume: 0.7

  # Поддерживаются:
  # - относительные пути ("./sounds")
  # - абсолютные пути ("/home/user/audio")
  sounds_dir: "./sounds"

  # Временные рамки, когда разрешены звуковые оповещения
  # Используется в логике SoundManager для блокировки воспроизведения вне диапазона
  notification_hours:
    # Начало разрешённого периода (формат HH:MM)
    # 00:00 — начало суток
    start: "00:00"

    # Конец разрешённого периода (формат HH:MM)
    # 23:59 — последняя минута суток
    end: "23:59"
```

Стоит отдельно рассмотреть секцию `notification_hours` — это своего рода **таймер, когда системе можно «говорить», а когда молчать**.

Пример: днём озвучка включена, ночью — тишина:

```yaml
notification_hours:
  start: "08:00"
  end: "23:00"
```

И так далее — подстраиваете под свой режим.

---

## Настройки уведомлений обдува вентилятора

```yaml
fan:
  notifications:
    on_off_phrases: true        # Озвучивать включение/выключение
    percent_phrases: true       # Озвучивать проценты
    percent_change_threshold: 0 # Порог изменения скорости (в процентах)
    announce_interval_sec: 10   # Интервал между оповещениями (сек)
```

Тут всё просто:

- `on_off_phrases: true/false` — озвучивать включение/выключение или нет.
- `percent_phrases: true/false` — озвучивать изменение процента или нет.
- `percent_change_threshold` — число от 0 до 99:
  - `0` — озвучивать любое изменение;
  - `1` — через 1%;
  - `10` — через 10% и т.д.
- `announce_interval_sec: 10` — минимальный интервал между оповещениями (чтобы, например, каждый процент не спамил).

---

## Настройки уведомлений статуса печати

```yaml
print_status:
  notifications:
    started: true    # Озвучивать начало печати
    completed: true  # Озвучивать завершение печати
    cancelled: true  # Озвучивать отмену печати
    paused: true     # Озвучивать паузу
    resumed: true    # Озвучивать возобновление
```

Здесь всё просто: `true` или `false` — озвучивать или нет.

---

## Настройки уведомлений прогресса печати

```yaml
progress:
  notifications:
    initial_estimate: true   # Озвучивать расчётное время печати в начале
    progress: true           # Озвучивать прогресс (%) во время печати
    elapsed_time: true       # Озвучивать прошедшее время печати
    remaining_time: true     # Озвучивать оставшееся время печати
    filament_usage: true     # Озвучивать расход филамента

  initial_estimate_source: "filename"   # "filename" или "calculation"
  unit_style: "compact"                 # "compact" или "auto"
  notification_intervals: "auto"        # "auto", число или список [1, 5, 10, 50, 90, 100]
  filament_units: "мм"                  # "грамм" / "мм"
  filament_density: 1.24                # г/см³ (для режима "грамм")
  filament_diameter: 1.75               # Диаметр филамента в мм (для режима "грамм")
```

Тут начинается интересное.

### Источник расчётного времени (`initial_estimate_source`)

Модуль может использовать:

- `"filename"`  
- `"calculation"`

**Если `"filename"`**

Например, OrcaSlicer по умолчанию вкладывает время в имя файла. Система парсит время, например:

- `FBG5-E3dV6-head_V1.0_RC_nozle_short_0.12mm_ABS_Generic Klipper Printer_24m27s.gcod`  
  → озвучит как «24 минуты 27 секунд».

- `Hannya Chunari_Wall Mask_0.08mm_ABS_Generic Klipper Printer_7d17h32m.gcode`  
  → «7 дней 17 часов 32 минуты».

Можно выбирать готовые шаблоны регулярных выражений (см. секцию `regex` ниже) или писать свои.

Если по каким-то причинам не удалось озвучить расчётное время из файла, система **автоматически**, по достижении 1% прогресса печати, озвучит время по прогнозам Klipper.

**Если `"calculation"`**

Тогда расчёт идёт **на основе данных от Klipper**, и, чтобы данные были более-менее нормальными, система дождётся 1% прогресса печати.

### Режим единиц расхода (`unit_style`)

`unit_style: "compact"` — режим «меньше слов». Комментарии говорят сами за себя.

- Если стоит режим `"auto"`, то всё озвучивается строго по единицам:
  мм → сантиметры → метры → километры.

  Пример:  
  «Расход филамента 1 километр 20 метров 45 сантиметров 4 миллиметра».

- Если стоит `"compact"`, специальная утилита найдёт оптимальное соотношение, как сказать так, чтобы было **меньше слов**. Это сокращает уведомление в разы. То же самое работает, если единица измерения — граммы (см. ниже).

### Интервалы уведомлений (`notification_intervals`)

Параметр отвечает за **частоту озвучивания процентов прогресса**:

- `"auto"` — автоматический режим. Система сама рассчитывает интервал, опираясь на длительность печати, чтобы:
  - короткие печати не спамили слишком часто;
  - длинные — озвучивались разумно по ходу.

- Число, например:
  - `notification_intervals: 1` — каждый процент;
  - `notification_intervals: 5` — каждые 5% и т.д.

- Список, например:
  ```yaml
  notification_intervals: [1, 5, 10, 50, 90, 100]
  ```
  В этом примере озвучит 1%, 5%, 10%, 50%, 90%, 100%.

**Важно:** все остальные оповещения этого модуля **привязаны к прогрессу печати**. Как он оповещает процент, так следом идут:

1. Процент прогресса.
2. Сколько времени прошло.
3. Сколько времени осталось.
4. Расход филамента.

### Единицы расхода филамента (`filament_units`)

- `"мм"` — расход озвучивается в миллиметрах, как задумано в Klipper.
- `"грамм"` — расход озвучивается в граммах, но нужно указать:

```yaml
filament_density: 1.24   # Плотность филамента г/см³
filament_diameter: 1.75  # Диаметр филамента в мм
```

---

## Регулярное выражение времени в имени файла

```yaml
time_pattern:
  # Основное регулярное выражение (латиница: d/h/m/s)
  # Находит блоки вида XdXhXmXs в любом месте имени файла
  regex: '(?:\d+d)?(?:\d+h)?(?:\d+m)?(?:\d+s)+'
  examples:
    - "file_1d2h30m.txt"
    - "project_2h45m.zip"
    - "backup_15m.7z"
    - "log_45s.log"
    - "data_1d2h.csv"
    - "report_3h45m10s.pdf"
```

Эта секция отвечает за **расчётное время печати из файла**: регулярное выражение и примеры (`examples`). То есть система не смотрит на расширение файла, её интересует только шаблон времени.

Ниже в конфиге могут быть закомментированы другие регулярки — можно использовать их или написать свою.

---

## Настройки уведомлений температуры

```yaml
temperature:
  enable_all_notifications: true   # Общий флаг включения уведомлений температуры

  bed:
    heating_off_alert: true        # Уведомлять об отключении нагрева стола
    heating_complete_alert: true   # Уведомлять о достижении целевой t для стола
    heating_complete_show_temp: true  # Показать температуру в уведомлении
    low_temperature_alert: true    # Уведомлять о низкой температуре стола
    low_temperature_need_temp: true   # Показать требуемую t при низкой температуре
    high_temperature_alert: true   # Уведомлять о высокой температуре стола
    high_temperature_need_temp: true  # Показать требуемую t при высокой температуре
    threshold_offset: 5            # Порог отклонения (в градусах) для стола

  extruder:
    heating_off_alert: true        # Аналогично для экструдера
    heating_complete_show_temp: true
    low_temperature_alert: true
    low_temperature_need_temp: true
    high_temperature_alert: true
    high_temperature_need_temp: true
    threshold_offset: 10           # Порог отклонения (в градусах) для экструдера
```

Тут всё просто, как написано в комментариях.  
Единственное, на что стоит обратить внимание, — `threshold_offset` для стола и экструдера.

### Логика `threshold_offset`

Рассмотрим сценарий:

- Принтер полностью остыл.
- Вы вводите целевую температуру (выше комнатной).

В этом случае порог **не имеет значения**: система просто скажет «низкая температура стола/экструдера, нужно столько-то градусов».

Если же целевая температура меняется, когда сопло или стол уже нагреты, вот тут нужен порог. В примере:

- экструдера: `10` градусов;
- стола: `5` градусов.

Как это работает:

- Текущая температура экструдера: 200  
  Вы меняете целевую на 205 → в порог **не вписалось** (10°), значит **молчим**.
- Текущая: 200, новая целевая: 180 → сразу срабатывает:  
  «высокая температура экструдера, нужно 180 градусов».
- В обратную сторону: было 180, ввели 200 →  
  «низкая температура, нужно 200 градусов».

Такая же логика для стола.

---

## Уведомления парковки (G28)

```yaml
g28_notifications:
  G28_X_START: true   # Уведомлять о начале парковки оси X
  G28_X_END: true     # Уведомлять о завершении парковки оси X
  G28_Y_START: true   # Ось Y — начало
  G28_Y_END: true     # Ось Y — завершение
  G28_Z_START: true   # Ось Z — начало
  G28_Z_END: true     # Ось Z — завершение
  G28_START: true     # Общая парковка — начало
  G28_END: true       # Общая парковка — завершение
```

## Уведомления построения bed mesh

```yaml
bed_mesh_notifications:
  BED_MESH_START: true           # Начало построения сетки стола
  BED_MESH_END: true             # Завершение построения сетки стола
  BED_MESH_ADAPTIVE_START: true  # Начало адаптивной сетки
  BED_MESH_ADAPTIVE_END: true    # Завершение адаптивной сетки
```

Эти модули будут работать **только если встроите в макросы** простые строчки `RESPOND MSG=` (ниже будет разбор). В остальном в комментариях всё указано: простое вкл/выкл.

---

## Ответы RESPOND, которые будут отловлены для обработки

Пример: `RESPOND MSG="G28 START"` будет отловлено и обработано как «парковка»,  
`RESPOND G28 X END` будет озвучено как «парковка оси X завершена».

```yaml
response:
  parking:
    G28_END: ["G28 END"]
    G28_X_START: ["G28 X START"]
    G28_X_END: ["G28 X END"]
    G28_Y_START: ["G28 Y START"]
    G28_Z_START: ["G28 Z START"]

  # Шаблоны для BedMeshNotifier (калибровка стола)
  bed_mesh:
    BED_MESH_START: ["BED_MESH START"]
    BED_MESH_END: ["BED_MESH END"]
    BED_MESH_ADAPTIVE_START: ["BED_MESH_ADAPTIVE START"]
    BED_MESH_ADAPTIVE_END: ["BED_MESH_ADAPTIVE END"]
```

Это главные шаблоны, какие `response` считывать на основе `RESPOND`. Менять можно то, что **в кавычках**, и соответственно встраивать в макросы.

### Пример макросов

```ini
[gcode_macro G28]
rename_existing: G28.1
gcode:
    {% if params.X is defined and params.Y is undefined and params.Z is undefined %}
        RESPOND MSG="G28 X START"
        G28.1 X
        RESPOND MSG="G28 X END"
    {% elif params.X is undefined and params.Y is defined and params.Z is undefined %}
        RESPOND MSG="G28 Y START"
        G28.1 Y
        RESPOND MSG="G28 Y END"
    {% elif params.X is undefined and params.Y is undefined and params.Z is defined %}
        RESPOND MSG="G28 Z START"
        G28.1 ZА
        RESPOND MSG="G28 Z END"
    {% elif params.X is defined and params.Y is defined and params.Z is undefined %}
        RESPOND MSG="G28 X START"
        G28.1 X
        RESPOND MSG="G28 X END"
        RESPOND MSG="G28 Y START"
        G28.1 Y
        RESPOND MSG="G28 Y END"
    {% elif (params.X is defined and params.Y is defined and params.Z is defined) or (params.X is undefined and params.Y is undefined and params.Z is undefined)  %}
        RESPOND MSG="G28 START"
        G28.1
        RESPOND MSG="G28 END"
    {% endif %}

```

Как видите, обычные `RESPOND` работают как **маркер** на срабатывание того или иного оповещения.

```ini
[gcode_macro BED_MESH_CALIBRATE]
rename_existing: BASE_BED_MESH_CALIBRATE
gcode:
    {% if params.ADAPTIVE is defined %}
      RESPOND MSG="BED_MESH_ADAPTIVE START"
      BASE_BED_MESH_CALIBRATE ADAPTIVE=1
      RESPOND MSG="BED_MESH_ADAPTIVE END"
    {% else %}
      RESPOND MSG="BED_MESH START"
      BASE_BED_MESH_CALIBRATE
      RESPOND MSG="BED_MESH END"
    {% endif %}
```

Тут тоже всё просто.

Важно: в `printer.cfg` должна быть секция:

```ini
[respond]
```

---

## Кастомный модуль (CustomNotifier)

Если кто-то захочет озвучивать свои события по `RESPOND` — например, обрыв прутка и т.п.

### Конфигурация пользовательских оповещений

```yaml
# Конфигурация пользовательских оповещений (CustomNotifier)
# Каждый блок соответствует отдельному шаблону уведомления
custom_notifier:
  test1:               # Уникальный ID шаблона (связан с custom_response.test1)
    true: true         # Флаг активации: true — отправлять оповещение, false — игнорировать
    aliace: ['один']   # Алиас для озвучки

  test22:              # Второй шаблон уведомления
    true: true         # Активирован
    aliace: ['двадцать', 'два']  # Можно список алиасов для составной озвучки
```

Можно называть свои секции как угодно и создавать их сколько хотите.

Пример нового типа:

```yaml
custom_notifier:
  error:               # Уникальный ID шаблона
    true: true         # Флаг активации
    aliace: ['ошибка'] # Алиас для озвучки
```

То есть создан новый тип уведомления, указан его `id`, который нужно применить ниже, флаг включен/выключен и алиас звука. Алиас может быть одиночным или составным (об этом ниже).

### Ответы RESPOND для CustomNotifier

```yaml
response:
  # Шаблоны для ParkingNotifier (парковка)
  parking:
    G28_START: ["G28 START"]
    G28_END: ["G28 END"]
    G28_X_START: ["G28 X START"]
    G28_X_END: ["G28 X END"]
    G28_Y_START: ["G28 Y START"]
    G28_Y_END: ["G28 Y END"]
    G28_Z_START: ["G28 Z START"]
    G28_Z_END: ["G28 Z END"]

  # Шаблоны для BedMeshNotifier (калибровка стола)
  bed_mesh:
    BED_MESH_START: ["BED_MESH START"]
    BED_MESH_END: ["BED_MESH END"]
    BED_MESH_ADAPTIVE_START: ["BED_MESH_ADAPTIVE START"]
    BED_MESH_ADAPTIVE_END: ["BED_MESH_ADAPTIVE END"]

  # Пользовательские шаблоны для модуля CustomNotifier
  # Каждый ключ — уникальный ID, связывающий response с настройками в custom_notifier
  custom_response:
    test1: ["test_response1"]     # При обнаружении "test_response1" активируется шаблон test1
    test22: ["test_response22"]   # При обнаружении "test_response22" активируется шаблон test22
```

Обратите внимание, как выглядят `id` и строки, которые нужно ловить.  
Пример: `test1: ["test_response1"]` — вам нужно будет послать:

```gcode
RESPOND MSG="test_response1"
```

Для второго примера:

```yaml
custom_notifier:
  error:
    true: true
    aliace: ['ошибка']
```

Нужно создать в `custom_response` шаблон:

```yaml
custom_response:
  error: ["error"]   # При обнаружении "error" активируется шаблон error
```

Теперь, введя:

```gcode
RESPOND MSG="error"
```

система озвучит: «Ошибка».

---

## Алиасы и их файлы

```yaml
# Алиасы и их файлы.
sounds:
```

Алиасы могут быть одиночные и составные.

### Одиночные алиасы

```yaml
  два: "два.mp3"
  двадцать: "двадцать.mp3"
  две: "две.mp3"
  двенадцать: "двенадцать.mp3"
  двести: "двести.mp3"
  девяносто: "девяносто.mp3"
  девятнадцать: "девятнадцать.mp3"
  девять: "девять.mp3"
  девятьсот: "девятьсот.mp3"
```

Каждый алиас → один файл.

### Составные алиасы

```yaml
  "['возобновление', 'печати']": "возобновление_печати.mp3"
  "['отмена', 'печати']": "отмена_печати.mp3"
  "['печать', 'завершена']": "печать_завершена.mp3"
  "['высокая', 'температура', 'стола']": "высокая_температура_стола.mp3"
  "['высокая', 'температура', 'экструдера']": "высокая_температура_экструдера.mp3"
  "['низкая', 'температура', 'стола']": "низкая_температура_стола.mp3"
```

Составные алиасы — это по сути список слов в предложении. Система видит, что пришло на озвучку, например:

> «низкая температура стола нужно двести градусов»

и заменяет фрагмент «низкая температура стола» на один файл, в котором уже есть эта часть фразы.

Изначально всё озвучивалось по принципу «один алиас — один файл». Для примера в конфиг уже помещены составные алиасы и нужные файлы, а неиспользуемые — закомментированы, одиночные файлы удалены. При создании кеша всё равно берутся только **алиасы**, а не реальный набор файлов.

---

## Рекомендации по алиасам

Если захотите, можно сделать **составные алиасы для чисел**. Сейчас используется **минимум** звуков, и фразы составляются из нескольких файлов. Например, 251 озвучивается как:

> «двести пятьдесят один»

Система работает с числами до 999, но для температур и прогресса достаточно составных алиасов до 300. Эту часть можно развить, но это долго, и пока в этом нет необходимости.

Сами алиасы **переназначать нельзя** (кроме `custom_notifier:` — это отдельный случай). Всё остальное вшито в систему. Система реагирует «вживую» в реальном времени при изменении:

- `sounds_dir:`
- названия файла для нужного алиаса (включая составные)

Если нужно — обновит кеш и контейнер (о нём ниже). В целом система автоматически реагирует на всё сама в реальном времени.

---

## Первый запуск и профили железа

Важно: так как у всех разное железо, система при первом запуске **применит профиль на основе вашего железа** и создаст файл-контейнер, из которого при дальнейших перезагрузках будет загружать данные в память. Время первого запуска зависит от железа. Первый запуск может занять несколько минут. Наберитесь терпения.

При успешном запуске вы услышите: «Система запущена».

Также полезно при глобальной перестройке или при первом запуске озвучки запускать скрипт **не как сервис**, а просто:

```bash
python3 main.py
```

Тогда вы увидите:

- какой профиль у вас применился;
- есть ли лишние файлы озвучки, которые не используются, на основе ваших алиасов.

---

## Единицы измерения и склонения

Остались **единицы измерения и склонения**: алиас и его файл.

Файлы можно менять, если:

- не нравится озвучка;
- вы перфекционист и создали все составные файлы со всеми возможными вариантами.

Система склонений работает **автоматом**, так что базовая конфигурация уже рассчитана на естественную речь.

# klipper_voice_manager

Установка:
Скачайте проект

```bash
git clone https://github.com/Ezhik3D/klipper_voice_manager.git
```

Перейдите в папку:
```bash
cd klipper_voice_manager
```

Полная установка:

```bash
bash install.sh
```

введите пароль для sudo по запросу, далее при запуске делайте это если нужно.

Установка только зависимостей:

```bash
bash install.sh --deps-only
```

Установка только сервиса:

```bash
bash install.sh --service-only
```

Удаление:
```bash
bash uninstall.sh
```

Рекомендация по первому запуску, сначала перейдите в папку с фалами, сделайте исполняемым скрипт install.sh, затем установите только зависимости. И запустите скрипт для проверки без запуска сервиса командой:

```bash
python3 main.py
```

Убедившись что нет ошибок и его работаспособности, можете выйти из выполнения по комбинации клавиш Ctrl+C. Затем запустите только установку сервиса. В будующем используйте это если будете переделывать озвучку, вывод вам всегда покажет ошибки и лишние файлы в папке со звуками.
